## 项目优化计划

### 一、基础认知与基线采集（约 1~1.5 周）
- 对现有 VM 进行性能与内存分配的基线测试，重点关注算术脚本（如 `md5.as`）的执行耗时与 GC 压力。
- 设计 `ScriptDatum`（值类型标记联合）数据结构，并梳理与当前 `ScriptObject` API 的兼容边界。
- 搭建分析工具，将 `code.txt` 中的指令流解析为频率与热点报告，为后续优化提供依据。

### 二、值类型化改造（约 2~3 周）
- 在执行栈、寄存器、局部变量等关键路径上引入 `ScriptDatum`，实现无装箱的数值与布尔运算。
- 为常用内建对象建立飞行重量实例池，减少重复分配。
- 保留原有原型/动态特性接口，在需要时通过轻量代理从值路径降级到对象路径。
- 编写回归测试，覆盖算术、逻辑、闭包、迭代器等核心场景，并复测性能基线。

### 三、CLR 互操作桥（约 2 周，和第四阶段并行推进）
- 构建脚本类型名到 CLR `Type` 的元数据缓存，预解析字段、属性、方法和构造函数信息。
- 基于 `DynamicMethod`/IL 动态生成访问/调用桩，支持实例与静态成员、对象创建；以签名作为缓存键重用桩代码。
- 实现高性能的参数与返回值编组：原生值直接映射，集合/字典采用池化转换器；在内存与性能冲突时优先性能。
- 增加互操作测试用例，覆盖字段读写、属性访问、方法调用、构造函数重载选择等。

### 四、字节码生成优化（约 1.5~2 周，和第三阶段并行推进）
- 在 AST 层实现常量折叠与字面量传播，减少冗余指令生成。
- 编写字节码窥孔优化器，针对 `code.txt` 中高频模式执行指令复合（如载入+运算合并、冗余 `PUSH_NULL` 消除）。
- 保持 opcode 编号向后兼容：复合指令选用空闲编号或使用模式标记，同时提供兼容开关以加载旧字节码。
- 建立自动化验证，以指令执行结果与性能对比确认优化收益。

### 五、收尾与文档（约 1 周）
- 执行全面的性能与内存回归，并根据数据调优缓存淘汰策略与池化阈值。
- 编写开发者文档：值类型体系说明、CLR 互操作 API 指南、字节码优化开关使用说明。
- 输出迁移指南，提示升级所需的注意事项与新旧行为差异。

> 若需要压缩周期，可考虑将 CLR 互操作与字节码优化并行推进，但需提前明确责任边界与测试覆盖。

